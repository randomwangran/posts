# -*- coding: utf-8 -*-
#+TITLE: Posts
#+AUTHOR: Tony aldon
#+DATE: <2022-03-23 Wed 16:03>

# This document is meant to be read inside Emacs.  To make the internal
# local links to Emacs and Org-mode repositories work correctly,
# make sure to clone those repositories under this directory:
#
#    git clone git://git.sv.gnu.org/emacs.git
#    git clone https://git.savannah.gnu.org/git/emacs/org-mode.git

#+LINK: emacs      ./emacs/
#+LINK: org-mode   ./org-mode/

* [2022-03-22 Tue] Org Speed Keys! BOOM! Great org-mode's feature! And a good OPPORTUNITY to talk about self-insert-command
:PROPERTIES:
:CUSTOM_ID: /2022-03-22/org-speed-keys-and-self-insert-command/
:REDDIT_POST: https://www.reddit.com/r/emacs/comments/tk8qou/org_speed_keys_boom_great_orgmodes_feature_and_a/
:END:

Hey Emacsers,

How are you doing?

This post is "pretty" special to me because I can still remember and
feel:

1) the first time I discovered Org Speed Keys and,
2) the first time I took a look at its implementation.

It was two AHA moments, one in my Emacs journey and the other in my
Elisp journey.

I hope you'll enjoy it :)

** Org Speed Keys

Org speed keys is not a minor mode but an org-mode feature that can be
turned on by setting the variable [[org-mode:lisp/org-keys.el::(defcustom org-use-speed-commands][org-use-speed-commands]] to ~t~.

It allows when the cursor is at a the beginning of a heading to call
a command by pressing a single "printing" key (keys that would
normally insert a character in the buffer).

For instance, if we are at the beginning of a heading, and we press
~n~, the cursor moves to the next visible heading (or stays at the
current heading if it's the last one in the buffer) if we use the
default bindings provided by org-mode in the variable
[[org-mode:lisp/org-keys.el::(defcustom org-speed-commands][org-speed-commands]].

It is "almost" the same that pressing ~C-c C-n~ but in SHORTER.  Isn't it
super cool???

If you've never tried it, go for it.

Just run:

: M-x eval-expression RET (setq org-use-speed-commands t)

Open one of your org documents then with the cursor at at the very
beginning of a heading press ~n~ or ~p~ repeatedly.

We can see org speed command bindings, by typing ~?~ (which call
[[org-mode:lisp/org-keys.el::(defun org-speed-command-help][org-speed-command-help]]) with the cursor at the very beginning of a
heading.  This pops up the following help buffer:

#+BEGIN_SRC text
Speed commands
==============

Outline Navigation
------------------
n   (org-speed-move-safe 'org-next-visible-heading)
p   (org-speed-move-safe 'org-previous-visible-heading)
f   (org-speed-move-safe 'org-forward-heading-same-level)
b   (org-speed-move-safe 'org-backward-heading-same-level)
F   org-next-block
B   org-previous-block
u   (org-speed-move-safe 'outline-up-heading)
j   org-goto
g   (org-refile '(4))

Outline Visibility
------------------
c   org-cycle
C   org-shifttab
    org-display-outline-path
s   org-toggle-narrow-to-subtree
k   org-cut-subtree
=   org-columns

... THERE ARE MORE ...

?   org-speed-command-help
#+END_SRC

If we want to use our own bindings, we can modify:

- the variable [[org-mode:lisp/org-keys.el::(defcustom org-speed-commands][org-speed-commands]] since org-mode 9.5,
- the variable ~org-speed-commands-user~ for previous versions.

Note: the variable ~org-speed-commands-user~ has been made obsolete
since org-mode 9.5 but it is still supported and should be removed
from org-mode 9.6 as we can read in the source code [[org-mode:lisp/org-keys.el]]:

#+BEGIN_SRC text
;; FIXME: don't check `org-speed-commands-user' past 9.6
#+END_SRC

** How does org-mode implement Org Speed keys?
*** Remapping [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]]

When org-mode is turned on, among other initialization tasks it remaps
the command [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] to the command [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]]
in the keymap [[org-mode:lisp/org-keys.el::(defvar org-mode-map][org-mode-map]] as we can see in the file [[org-mode:lisp/org-keys.el]]:

#+BEGIN_SRC emacs-lisp
(org-remap org-mode-map
           'self-insert-command    'org-self-insert-command
           'delete-char            'org-delete-char
           'delete-backward-char   'org-delete-backward-char
           'kill-line              'org-kill-line
           'open-line              'org-open-line
           'yank                   'org-yank
           'comment-dwim           'org-comment-dwim
           'move-beginning-of-line 'org-beginning-of-line
           'move-end-of-line       'org-end-of-line
           'forward-paragraph      'org-forward-paragraph
           'backward-paragraph     'org-backward-paragraph
           'backward-sentence      'org-backward-sentence
           'forward-sentence       'org-forward-sentence
           'fill-paragraph         'org-fill-paragraph
           'delete-indentation     'org-delete-indentation
           'transpose-words        'org-transpose-words)
#+END_SRC

In the case of [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]], the preceding remapping can be
written like this (this is what [[org-mode:lisp/org-keys.el::(defun org-remap][org-remap]] does):

#+BEGIN_SRC emacs-lisp
(define-key org-mode-map [remap self-insert-command] 'org-self-insert-command)
#+END_SRC

As a consequence, in org-mode, when we press a printing key (that
would by default insert a character in the buffer), let say we press ~n~,
the "command loop editor" does several things:

1) it performs a key lookup for ~n~ in the current active maps and find
   that ~n~ is bound to [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] (due to the default binding
   in the keymap [[emacs:lisp/subr.el::(defvar global-map][global-map]] which is the global map by default), then,
2) it checks if the command [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] has a remapping in the
   current active maps (with the function [[emacs:src/keymap.c::DEFUN ("command-remapping"][command-remapping]]),
3) it finds that [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] is remapped to
   [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] (due to the remapping in the keymap
   [[org-mode:lisp/org-keys.el::(defvar org-mode-map][org-mode-map]]) and instead of calling [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]],
   it calls [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]].

Now, the command [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] has the complete power over
the actions to perform.  Nothing forces it to insert the character ~n~
in the buffer.

*** If it is magic, this is [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]]

Before talking about how [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] performs speed keys,
let me ask you some questions:

- Have you ever noticed that when you modify the title of a headline
  the tags are automatically re-aligned?  Guess what?  This is
  [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] in action (calling [[org-mode:lisp/org.el::(defun org-fix-tags-on-the-fly][org-fix-tags-on-the-fly]]
  just after inserting a character).
- Have you ever noticed that inserting less characters in a table field
  than its width doesn't move the right bar of the field?  This is
  [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] in action.
- Did you know that in a table, if you type printing keys just after
  moving with ~TAB~, ~S-TAB~, ~RET~, the table field is made blank before
  inserting the characters (with [[org-mode:lisp/org-table.el::(defcustom org-table-auto-blank-field][org-table-auto-blank-field]] set to ~t~)?
  This is also [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]]
  (see [[https://www.youtube.com/watch?v=w4wxGOijyZs][Inside Emacs #6 (part 5) Why is it so fast to edit tables with org-table?]]).

*** [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] implementation

Let's get back to our example.  We've pressed the "printing" key ~n~ and
"the command loop editor" has called [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]].

The command [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] does the following (assuming we
have set [[org-mode:lisp/org-keys.el::(defcustom org-use-speed-commands][org-use-speed-commands]] to ~t~):

1) locally set the variable ~kv~ to the vector ~[?n]~ corresponding to the
   key sequence that invoked the command [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] (the
   "printing" key ~n~ we've pressed),
2) run the hook [[org-mode:lisp/org-keys.el::(defcustom org-speed-command-hook][org-speed-command-hook]] "until success" with the
   argument ~"n"~ (a string, corresponding to the evaluation of
   ~(make-string 1 (aref [?n] 0))~ knowing that ~kv~ is ~[?n]~).
   Considering that the hook [[org-mode:lisp/org-keys.el::(defcustom org-speed-command-hook][org-speed-command-hook]] is equal to the
   list ~(org-speed-command-activate org-babel-speed-command-activate)~
   by default, the function [[emacs:src/eval.c::DEFUN ("run-hook-with-args-until-success"][run-hook-with-args-until-success]] evaluate
   successively the forms:
   1) ~(org-speed-command-activate "n")~,
   2) ~(org-babel-speed-command-activate "n")~,
   stopping at the first one that returns non-nil, and return that
   value, or return ~nil~ if both evaluate to ~nil~.
3) Then, this returned value becomes the value of the variable
   ~org-speed-command~,
4) if ~org-speed-command~ is either a command, a function or a non empty
   list, ~org-speed-command~ is called or evaluated (and
   [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] returns "maybe" witout inserting ~n~ in the
   buffer).  If ~org-speed-command~ is neither a command, a function nor
   a non empty list, the command [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] is called
   with the variable [[org-mode:lisp/org-keys.el::(defcustom org-use-speed-commands][org-use-speed-commands]] locally set to ~nil~ which
   leads to skip the first clause of the special form ~cond~ in the body
   of [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]], and [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]] among other
   "actions" will insert the character ~n~ in the buffer.

Below you can see the parts of the command [[org-mode:lisp/org.el::(defun org-self-insert-command][org-self-insert-command]]
related to the speed keys feature that we have just discussed:

#+BEGIN_SRC emacs-lisp
(defun org-self-insert-command (N)
  ;; ...
  (interactive "p")
  (cond
   ((and org-use-speed-commands
         (let ((kv (this-command-keys-vector)))
           (setq org-speed-command
                 (run-hook-with-args-until-success
                  'org-speed-command-hook
                  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp org-speed-command)
      (setq this-command org-speed-command)
      (call-interactively org-speed-command))
     ((functionp org-speed-command)
      (funcall org-speed-command))
     ((and org-speed-command (listp org-speed-command))
      (eval org-speed-command))
     (t (let (org-use-speed-commands)
          (call-interactively 'org-self-insert-command)))))
   ((and
     ;; ...
     (org-at-table-p)
     ;; ....
     )
    (self-insert-command N)
    ;; ...
    )
   (t
    ;; ...
    (self-insert-command N)
    (org-fix-tags-on-the-fly)
    ;; ...
    )))
#+END_SRC

*** [[org-mode:lisp/org-keys.el::(defun org-speed-command-activate][org-speed-command-activate]]

We still have one function to cover: [[org-mode:lisp/org-keys.el::(defun org-speed-command-activate][org-speed-command-activate]]
(knowing that [[org-mode:lisp/org-keys.el::(defun org-babel-speed-command-activate][org-babel-speed-command-activate]] does "almost the same
thing" but for the cursor at the beginning of source blocks).

Indeed, continuing with our example, if evaluating
~(org-speed-command-activate "n")~ returns a command  (a function or a
non empty list) this command will be called instead of inserting the
character ~"n"~.

In the simple case, when [[org-mode:lisp/org-keys.el::(defcustom org-use-speed-commands][org-use-speed-commands]] is set to ~t~ (it could
also be a function), [[org-mode:lisp/org-keys.el::(defun org-speed-command-activate][org-speed-command-activate]] checks:

1) if the point (the cursor) is at the beginning of line ~(bolp)~ and,
2) if this line is a heading ~(looking-at org-outline-regexp)~.

If true, [[org-mode:lisp/org-keys.el::(defun org-speed-command-activate][org-speed-command-activate]] looks for the key ~"n"~ in the alist
[[org-mode:lisp/org-keys.el::(defcustom org-speed-commands][org-speed-commands]] defined by default like this:

#+BEGIN_SRC emacs-lisp
(defcustom org-speed-commands
  '(("Outline Navigation")
    ("n" . (org-speed-move-safe 'org-next-visible-heading))
    ("p" . (org-speed-move-safe 'org-previous-visible-heading))
    ("f" . (org-speed-move-safe 'org-forward-heading-same-level))
    ("b" . (org-speed-move-safe 'org-backward-heading-same-level))
    ("F" . org-next-block)
    ("B" . org-previous-block)
    ;; ...
    ))
#+END_SRC

and returns the s-exp associated with the key ~"n"~ which is by default:

: (org-speed-move-safe 'org-next-visible-heading)

As we left aside the case where [[org-mode:lisp/org-keys.el::(defcustom org-use-speed-commands][org-use-speed-commands]] is a function
and we anticipate the org-mode version 9.6, we can write a simplified
version of [[org-mode:lisp/org-keys.el::(defun org-speed-command-activate][org-speed-command-activate]], that we call
~org-speed-command-activate-SIMPLE~, like this:

#+BEGIN_SRC emacs-lisp
(defun org-speed-command-activate-SIMPLE (keys)
  (when (and (bolp) (looking-at org-outline-regexp))
    (cdr (assoc keys org-speed-commands))))
#+END_SRC

So, when we presse the key ~n~ (in org-mode):
org-babel-next-src-block
1) if we are at the beginning of a heading, the cursor is
   moved "safely" to the next visible heading,
2) if we are at the beginning of a source block (due to
   [[org-mode:lisp/org-keys.el::(defun org-babel-speed-command-activate][org-babel-speed-command-activate]] in the hook
   [[org-mode:lisp/org-keys.el::(defcustom org-speed-command-hook][org-speed-command-hook]]), the cursor is moved to the next source
   block,
3) and if we were anywhere else, the character ~n~ is inserted in the
   buffer.

We are done with the mechanism of Org Speed Keys.

Let's talk a bit about the command [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]].

** [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]]
*** Bindings of printing characters to [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] in the keymap [[emacs:lisp/subr.el::(defvar global-map][global-map]]

In this section, our goal is to see what are the printing characters
that are bound to the command [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]].

In the info node [[info:elisp#Controlling Active Maps]], we can read the
following:

#+BEGIN_SRC text
-- Variable: global-map
    This variable contains the default global keymap that maps Emacs
    keyboard input to commands.  The global keymap is normally this
    keymap.  The default global keymap is a full keymap that binds
    ‘self-insert-command’ to all of the printing characters.
#+END_SRC

Indeed, the variable [[emacs:lisp/subr.el::(defvar global-map][global-map]] is defined in the file [[emacs:lisp/subr.el]]
and is set to be the global keymap (using [[emacs:src/keymap.c::DEFUN ("use-global-map"][use-global-map]]) as we can
see:

#+BEGIN_SRC emacs-lisp
(defvar global-map
  (let ((map (make-keymap)))
    ;; ...
    (define-key map "\C-i" #'self-insert-command)
    (let* ((vec1 (make-vector 1 nil))
           (f (lambda (from to)
                (while (< from to)
                  (aset vec1 0 from)
                  (define-key map vec1 #'self-insert-command)
                  (setq from (1+ from))))))
      (funcall f #o040 #o0177)
      (when (eq system-type 'ms-dos)      ;FIXME: Why?
        (funcall f #o0200 #o0240))
      (funcall f #o0240 #o0400))

    (define-key map "\C-a" #'beginning-of-line)
    (define-key map "\C-b" #'backward-char)
    (define-key map "\C-e" #'end-of-line)
    (define-key map "\C-f" #'forward-char)
    ;; ...
    map)
  "..."
  )
(use-global-map global-map)
#+END_SRC

Many bindings in the keymap [[emacs:lisp/subr.el::(defvar global-map][global-map]] are added in other files.  For
instance the key sequences ~C-g~, ~C-u~, ~C-k~, ~C-w~ and ~C-y~ are added to
[[emacs:lisp/subr.el::(defvar global-map][global-map]] in the file [[emacs:lisp/bindings.el]] like this:

#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-g" 'keyboard-quit)
(define-key global-map "\C-u" 'universal-argument)
(define-key global-map "\C-k" 'kill-line)
(define-key global-map "\C-w" 'kill-region)
(define-key global-map "\C-y" 'yank)
#+END_SRC

Now, let's focus in the ~let*~ binding in the definition of the keymap
[[emacs:lisp/subr.el::(defvar global-map][global-map]].  In this ~let*~ binding, we define a function ~f~ that binds in
the local keymap ~map~ all the characters (represented as integer)
between ~from~ to ~to~ (excluded), and we apply it to the following
limits (excluding the ms-dos case):

1) from ~#o040~ to ~#o0177~,
2) from ~#o0240~ to ~#o0400~.

If it is not clear what are the printing characters that are bound to
[[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] in the keymap [[emacs:lisp/subr.el::(defvar global-map][global-map]] we can "list" them like
this:

#+BEGIN_SRC emacs-lisp
(with-temp-buffer
  (dotimes (i (- #o0177 #o040))
    (insert (+ #o040 i)))
  (buffer-string))
;; " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"

(with-temp-buffer
  (dotimes (i (- #o0400 #o0240))
    (insert (+ #o0240 i)))
  (buffer-string))
;; " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ"
#+END_SRC

*** Remapping [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] to [[emacs:lisp/subr.el::(defun undefined][undefined]] in [[emacs:lisp/info.el::(define-derived-mode Info-mode][Info-mode]], [[emacs:lisp/help-mode.el::(define-derived-mode help-mode][help-mode]] and [[emacs:lisp/simple.el::(define-derived-mode special-mode][special-mode]]

In some cases (like in [[emacs:lisp/info.el::(define-derived-mode Info-mode][Info-mode]] and [[emacs:lisp/help-mode.el::(define-derived-mode help-mode][help-mode]]) we want to override
all printing keys to be undefined before remapping some of them to
specific commands.

This is done by remapping in the local keymap the command
[[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] to the function [[emacs:lisp/subr.el::(defun undefined][undefined]].

Note that remapping [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] to ~nil~ in the local keymaps
won't override [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] in the global map as we can read in
the info node [[info:elisp#Key Lookup]]:

#+BEGIN_SRC text
The symbol ‘undefined’ is worth special mention: it means to treat
the key as undefined.  Strictly speaking, the key is defined, and
its binding is the command ‘undefined’; but that command does the
same thing that is done automatically for an undefined key: it
rings the bell (by calling ‘ding’) but does not signal an error.

‘undefined’ is used in local keymaps to override a global key
binding and make the key undefined locally.  A local binding of
‘nil’ would fail to do this because it would not override the
global binding.
#+END_SRC

In the case of [[emacs:lisp/info.el::(define-derived-mode Info-mode][Info-mode]] this is done by calling the function
[[emacs:lisp/subr.el::(defun suppress-keymap][suppress-keymap]] (which overrides all printing keys to be undefined,
maps ~-~ to the command [[emacs:lisp/simple.el::(defun negative-argument][negative-argument]] and the numbers 0,1,..., 9 to
the command [[emacs:lisp/simple.el::(defun digit-argument][digit-argument]]), when defining the keymap [[emacs:lisp/info.el::(defvar Info-mode-map][Info-mode-map]] as
follow:

#+BEGIN_SRC emacs-lisp
(defvar Info-mode-map
  (let ((map (make-keymap)))
    (suppress-keymap map)
    ;; ...
    (define-key map "1" 'Info-nth-menu-item)
    (define-key map "2" 'Info-nth-menu-item)
    ;;...
    (define-key map "n" 'Info-next)
    (define-key map "p" 'Info-prev)
    (define-key map "q" 'quit-window)
    ;;...
    map)
  "...")
#+END_SRC

In the case of [[emacs:lisp/help-mode.el::(define-derived-mode help-mode][help-mode]] this is done by setting the parent keymap of
[[emacs:lisp/help-mode.el::(defvar help-mode-map][help-mode-map]] to be a composed keymap of [[emacs:lisp/button.el::(defvar button-buffer-map][button-buffer-map]] and the
parent map [[emacs:lisp/simple.el::(defvar special-mode-map][special-mode-map]] (which overrides all printing keys to be
undefined, maps ~-~ to the command [[emacs:lisp/simple.el::(defun negative-argument][negative-argument]] and the numbers
0,1,..., 9 to the command [[emacs:lisp/simple.el::(defun digit-argument][digit-argument]]), as we can see below:

#+BEGIN_SRC emacs-lisp
(defvar help-mode-map
  (let ((map (make-sparse-keymap)))
    (set-keymap-parent map (make-composed-keymap button-buffer-map
                                                 special-mode-map))
    (define-key map "n" 'help-goto-next-page)
    (define-key map "p" 'help-goto-previous-page)
    ;; ...
    map)
  "..."
  )
#+END_SRC

*** Best function name ever: [[emacs:src/dispnew.c::bitch_at_user (void)][bitch_at_user]]

[[emacs:src/dispnew.c::bitch_at_user (void)][bitch_at_user]]!!!

What a beautiful name for a function!

This is a ~C~ function we can find in Emacs source code.  If I'm not
wrong it is called in the body of 3 functions.  Mainly, this function
when called will ring the bell.  This function is defined in the file
[[emacs:src/dispnew.c]] as follow:

#+BEGIN_SRC c
void
bitch_at_user (void)
{
  if (noninteractive)
    putchar (07);
  else if (!INTERACTIVE)  /* Stop executing a keyboard macro.  */
    {
      const char *msg
        = "Keyboard macro terminated by a command ringing the bell";
      Fsignal (Quser_error, list1 (build_string (msg)));
    }
  else
    ring_bell (XFRAME (selected_frame));
}
#+END_SRC

Why talking about this function?

Because its name is AMAZING and because I encounter it when I was
reading the source code of [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]].

Indeed, the function [[emacs:src/dispnew.c::bitch_at_user (void)][bitch_at_user]] is called in the body of
[[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] when the command [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] is invoked by
a key sequence that is not a printing key.

For instance, we can trigger it by binding for the key sequence ~C-<f1>~
(pick any key sequence you are not using) to [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] like
this:

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-<f1>") 'self-insert-command)
#+END_SRC

And now, if we press ~C-<f1>~, we trigger the function [[emacs:src/dispnew.c::bitch_at_user (void)][bitch_at_user]] and:

1) we see ~Wrong type argument: characterp, C-f1~ in the echo area and,
2) depending on the "setting of the bell" (see [[info:elisp#Beeping]]) a)
   nothing more happens, b) we hear the bell ringing, or c) we see the
   screen flashing.

AS NO SENTENCE CAN BEAT THE SOURCE CODE, here is the source code of
[[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] defined in the file [[emacs:src/cmds.c]]:

#+BEGIN_SRC c
DEFUN ("self-insert-command", Fself_insert_command, Sself_insert_command, 1, 2,
       "(list (prefix-numeric-value current-prefix-arg) last-command-event)",
       doc: /* Insert the character you type.
Whichever character C you type to run this command is inserted.
The numeric prefix argument N says how many times to repeat the insertion.
Before insertion, `expand-abbrev' is executed if the inserted character does
not have word syntax and the previous character in the buffer does.
After insertion, `internal-auto-fill' is called if
`auto-fill-function' is non-nil and if the `auto-fill-chars' table has
a non-nil value for the inserted character.  At the end, it runs
`post-self-insert-hook'.  */)
  (Lisp_Object n, Lisp_Object c)
{
  CHECK_FIXNUM (n);

  /* Backward compatibility.  */
  if (NILP (c))
    c = last_command_event;

  if (XFIXNUM (n) < 0)
    error ("Negative repetition argument %"pI"d", XFIXNUM (n));

  if (XFIXNAT (n) < 2)
    call0 (Qundo_auto_amalgamate);

  /* Barf if the key that invoked this was not a character.  */
  if (!CHARACTERP (c))
    bitch_at_user ();
  else {
    int character = translate_char (Vtranslation_table_for_input,
                                    XFIXNUM (c));
    int val = internal_self_insert (character, XFIXNAT (n));
    if (val == 2)
      Fset (Qundo_auto__this_command_amalgamating, Qnil);
    frame_make_pointer_invisible (SELECTED_FRAME ());
  }

  return Qnil;
}
#+END_SRC

WE ARE DONE!!!

* [2022-03-11 Fri] Did you know that org-mode's source code contains more than 5000 examples?
:PROPERTIES:
:CUSTOM_ID: /2022-03-11/org-mode-source-code-5000-examples/
:REDDIT_POST: https://www.reddit.com/r/emacs/comments/tblodh/did_you_know_that_orgmodes_source_code_contains/
:END:

Hey org-mode lovers,

Have you ever been in the following situation?

You have tried to understand a specific aspect of org-mode (say a
command) and you have done the following:

1) you have played with the command (writing your own examples),
2) you have read all the parts in the manual dealing with this
   command,
3) you have read the docstring of the command,
4) you have looked for explanations on the web,
5) you even have read the source code of the command,

but you still haven't figured it out after all the efforts.

I've been in that situation and I thought it would be easier if there
were more examples.

BUT THERE ARE MORE EXAMPLES.

We just have to change our lenses to see them.

What if we looked at org-mode tests as examples of org-mode?

BOOM we have our <<5000 examples>>.

Before going any further, let's make it clear that we don't need to
understand or know how to use [[emacs:lisp/emacs-lisp/ert.el][ert]] (the built-in package used for
testing) to benefit from org-mode testing.

And this post is not about [[emacs:lisp/emacs-lisp/ert.el][ert]] testing but about the information
that we can get from the org-mode test suite.

In this post, we use the example of the command [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]]
(bound by default to ~M-<RET>~, that allows to insert a new heading or
item with the same depth at point)  to "demonstrate" that the tests
are indeed examples.

Let's assume, we are already familiar with [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]], we use it
every day, but sometimes we don't understand why it behaves the way it
does.

What can we do to find out the truth about [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]]?

*** reader feedback                                               :nonexport:
    :PROPERTIES:
    :LAST_MODIFIED: [2022-03-25 Fri 15:32]
    :END:
How do you count [[5000 examples]]?
** Org manual

First of all, we can take a look in the manual of org.

In the info node [[info:org#Plain Lists]] we can read:

#+BEGIN_SRC text
‘M-<RET>’ (‘org-insert-heading’)
     Insert new item at current level.  With a prefix argument, force a
     new heading (see Structure Editing).  If this command is
     used in the middle of an item, that item is _split_ in two, and the
     second part becomes the new item(5).  If this command is executed
     _before item’s body_, the new item is created _before_ the current
     one.

...

   (5) If you do not want the item to be split, customize the variable
‘org-M-RET-may-split-line’.
#+END_SRC

That might be enough, but let's say it isn't, and we continue our
investigation to find the truth.

** Help buffer

Secondly, we can have more information about [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]]
by reading its docstring by running:

: C-h f org-insert-heading RET

which pops up this help buffer:

#+BEGIN_SRC text
org-insert-heading is an interactive compiled Lisp function.

(org-insert-heading &optional ARG INVISIBLE-OK TOP)

Insert a new heading or an item with the same depth at point.

If point is at the beginning of a heading, insert a new heading
or a new headline above the current one.  When at the beginning
of a regular line of text, turn it into a heading.

If point is in the middle of a line, split it and create a new
headline with the text in the current line after point (see
‘org-M-RET-may-split-line’ on how to modify this behavior).  As
a special case, on a headline, splitting can only happen on the
title itself.  E.g., this excludes breaking stars or tags.

With a ‘C-u’ prefix, set ‘org-insert-heading-respect-content’ to
a non-nil value for the duration of the command.  This forces the
insertion of a heading after the current subtree, independently
on the location of point.

With a ‘C-u C-u’ prefix, insert the heading at the end of the tree
above the current heading.  For example, if point is within a
2nd-level heading, then it will insert a 2nd-level heading at
the end of the 1st-level parent subtree.

When INVISIBLE-OK is set, stop at invisible headlines when going
back.  This is important for non-interactive uses of the
command.

When optional argument TOP is non-nil, insert a level 1 heading,
unconditionally.
#+END_SRC

Now we not only know what the command does but also how to call it.

There is also some information about its non-interactive use.

Reading the Org manual and its docstring may have given us the
information we wanted, but let's say we want to know more and continue
our investigation to find the truth.

** The source code

The truth resides in the source code!  Isn't that right?

Ok, let's take a look at the command [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] defined in the
file [[org-mode:lisp/org.el]] as follow:

#+BEGIN_SRC emacs-lisp
(defun org-insert-heading (&optional arg invisible-ok top)
  ;; HERE WAS THE DOCSTRING
  (interactive "P")
  (let* ((blank? (org--blank-before-heading-p (equal arg '(16))))
         (level (org-current-level))
         (stars (make-string (if (and level (not top)) level 1) ?*)))
    (cond
     ((or org-insert-heading-respect-content
          (member arg '((4) (16)))
          (and (not invisible-ok)
               (invisible-p (max (1- (point)) (point-min)))))
      ;; Position point at the location of insertion.  Make sure we
      ;; end up on a visible headline if INVISIBLE-OK is nil.
      (org-with-limited-levels
       (if (not level) (outline-next-heading) ;before first headline
         (org-back-to-heading invisible-ok)
         (when (equal arg '(16)) (org-up-heading-safe))
         (org-end-of-subtree)))
      (unless (bolp) (insert "\n"))
      (when (and blank? (save-excursion
                          (backward-char)
                          (org-before-first-heading-p)))
        (insert "\n")
        (backward-char))
      (when (and (not level) (not (eobp)) (not (bobp)))
        (when (org-at-heading-p) (insert "\n"))
        (backward-char))
      (unless (and blank? (org-previous-line-empty-p))
        (org-N-empty-lines-before-current (if blank? 1 0)))
      (insert stars " ")
      ;; When INVISIBLE-OK is non-nil, ensure newly created headline
      ;; is visible.
      (unless invisible-ok
        (pcase (get-char-property-and-overlay (point) 'invisible)
          (`(outline . ,o)
           (move-overlay o (overlay-start o) (line-end-position 0)))
          (_ nil))))
     ;; At a headline...
     ((org-at-heading-p)
      (cond ((bolp)
             (when blank? (save-excursion (insert "\n")))
             (save-excursion (insert stars " \n"))
             (unless (and blank? (org-previous-line-empty-p))
               (org-N-empty-lines-before-current (if blank? 1 0)))
             (end-of-line))
            ((and (org-get-alist-option org-M-RET-may-split-line 'headline)
                  (org-match-line org-complex-heading-regexp)
                  (org-pos-in-match-range (point) 4))
             ;; Grab the text that should moved to the new headline.
             ;; Preserve tags.
             (let ((split (delete-and-extract-region (point) (match-end 4))))
               (if (looking-at "[ \t]*$") (replace-match "")
                 (org-align-tags))
               (end-of-line)
               (when blank? (insert "\n"))
               (insert "\n" stars " ")
               (when (org-string-nw-p split) (insert split))))
            (t
             (end-of-line)
             (when blank? (insert "\n"))
             (insert "\n" stars " "))))
     ;; On regular text, turn line into a headline or split, if
     ;; appropriate.
     ((bolp)
      (insert stars " ")
      (unless (and blank? (org-previous-line-empty-p))
        (org-N-empty-lines-before-current (if blank? 1 0))))
     (t
      (unless (org-get-alist-option org-M-RET-may-split-line 'headline)
        (end-of-line))
      (insert "\n" stars " ")
      (unless (and blank? (org-previous-line-empty-p))
        (org-N-empty-lines-before-current (if blank? 1 0))))))
  (run-hooks 'org-insert-heading-hook))
#+END_SRC

You can get org-mode's source code by running the following command:

: git clone https://git.savannah.gnu.org/git/emacs/org-mode.git

Ok...

The source code helps, but now we need to know a lot more about the
implementations of ~org-mode~ and ~emacs/elisp~ than we want to spend time
on.

Indeed, if we want to understand the implementation of
[[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] we have to understand:

1) (org API) ~org--blank-before-heading-p~, ~org-current-level~,
   ~org-with-limited-levels~, ~outline-next-heading~, ~org-back-to-heading~,
   ~org-up-heading-safe~, ~org-end-of-subtree~,
   ~org-before-first-heading-p~, ~org-N-empty-lines-before-current~, etc.,
2) (emacs/elisp API) ~make-string~, ~member~, ~invisible-p~, ~bolp~,
   ~save-excursion~, ~eobp~, ~bobp~, ~pcase~, ~get-char-property-and-overlay~, etc.

So, what can we do?

Maybe we can look at the test of the command [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]].

** The Tests (aka. "The Examples")
*** [[org-mode:testing/lisp/test-org.el::(ert-deftest test-org/insert-heading][test-org/insert-heading]]

In the directory [[org-mode:testing]], doing a search for
[[org-mode:testing/lisp/test-org.el::(ert-deftest
test-org/insert-heading][test-org/insert-heading]] [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] using ~grep~ (or ~ripgrep~)
shows that the command [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] is tested in the [[emacs:lisp/emacs-lisp/ert.el][ert]] test
[[org-mode:testing/lisp/test-org.el::(ert-deftest
test-org/insert-heading][test-org/insert-heading]] defined in the file
[[org-mode:testing/lisp/test-org.el]] as follow (we reproduce only the
first 4 [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] forms - it contains 28 [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] forms and 1 [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-not][should-not]]
form):

#+BEGIN_SRC emacs-lisp
(ert-deftest test-org/insert-heading ()
  "Test `org-insert-heading' specifications."
  ;; In an empty buffer, insert a new headline.
  (should
   (equal "* "
          (org-test-with-temp-text ""
            (org-insert-heading)
            (buffer-string))))
  ;; At the beginning of a line, turn it into a headline.
  (should
   (equal "* P"
          (org-test-with-temp-text "<point>P"
            (org-insert-heading)
            (buffer-string))))
  ;; In the middle of a line, split the line if allowed, otherwise,
  ;; insert the headline at its end.
  (should
   (equal "Para\n* graph"
          (org-test-with-temp-text "Para<point>graph"
            (let ((org-M-RET-may-split-line '((default . t))))
              (org-insert-heading))
            (buffer-string))))
  (should
   (equal "Paragraph\n* "
          (org-test-with-temp-text "Para<point>graph"
            (let ((org-M-RET-may-split-line '((default . nil))))
              (org-insert-heading))
            (buffer-string))))
  ;; ...
  )
#+END_SRC

What can we observe from those 4 [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] forms?

1) they have the same "shape", so we can deduce that if we understand
   how the first one works, we will understand the others,
2) they use only a few symbols (much less than in the source code of
   [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]]):
   - [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] from [[emacs:lisp/emacs-lisp/ert.el][ert]] package,
   - ~equal~, ~let~ and ~buffer-string~ from Emacs/Elisp,
   - [[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]] specific to Org test suite and
   - [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] and [[org-mode:lisp/org.el::(defcustom org-M-RET-may-split-line][org-M-RET-may-split-line]], the command and
     the variable we are testing.

Now let's describe these [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] forms in words as best we can.

After doing this, perhaps we will think of these [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] forms as small
examples, each describing a behavior of the command [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]].

*** Example 1

The first [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] form:

#+BEGIN_SRC emacs-lisp
(should
   (equal "* "
          (org-test-with-temp-text ""
            (org-insert-heading)
            (buffer-string))))
#+END_SRC

could be translated like this:

1) in a temporary buffer in org-mode ([[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]]),
2) keep the buffer empty (~""~),
3) keep the point at the beginning,
4) call [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]],
5) return the string from the temporary buffer (~buffer-string~),
6) compare this string to the string ~"* "~ (~equal~),
7) if they are equal, return ~t~, if not, return the error
   ~ert-test-failed~ ([[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]]).

*** [[emacs:lisp/emacs-lisp/ert.el][ert]] and [[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]]

To evaluate the preceding form we need to have [[emacs:lisp/emacs-lisp/ert.el][ert]] loaded (for the
macro [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]]) which can be achieve by evaluating the following form:

#+BEGIN_SRC emacs-lisp
(require 'ert)
#+END_SRC

and we need the macro [[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]] (defined in the file
[[org-mode:testing/org-test.el]]) to be defined which can be done by
evaluating its definition:

#+BEGIN_SRC emacs-lisp
(defmacro org-test-with-temp-text (text &rest body)
  (declare (indent 1))
  `(let ((inside-text (if (stringp ,text) ,text (eval ,text)))
         (org-mode-hook nil))
     (with-temp-buffer
       (org-mode)
       (let ((point (string-match "<point>" inside-text)))
         (if point
             (progn
               (insert (replace-match "" nil nil inside-text))
               (goto-char (1+ (match-beginning 0))))
           (insert inside-text)
           (goto-char (point-min))))
       (font-lock-ensure (point-min) (point-max))
       ,@body)))
#+END_SRC

*** [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]], [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-not][should-not]], [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-error][should-error]]

Our examples only use the macro [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] but if we want to read more
tests it is useful to know the macros [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-not][should-not]] and [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-error][should-error]] that
[[emacs:lisp/emacs-lisp/ert.el][ert]] package provides.

In the following Elisp snippet, we give some examples of the use of
[[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]], [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-not][should-not]] and [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should-error][should-error]]:

#+BEGIN_SRC emacs-lisp
(should 3)   ; 3
(should t)   ; t
(should nil)
;; Debugger entered--Lisp error: (ert-test-failed ((should nil) :form nil :value nil))

(should-not nil) ; nil
(should-not t)
;; Debugger entered--Lisp error: (ert-test-failed ((should-not t) :form t :value t))

(should-error (= "1" 1)) ; (wrong-type-argument number-or-marker-p "1")
(should-error t)
;; Debugger entered--Lisp error: (ert-test-failed ((should-error t) :form t :value t :fail-reason "did not signal an error"))
#+END_SRC

*** Example 2

The second [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] form:

#+BEGIN_SRC emacs-lisp
(should
 (equal "* P"
        (org-test-with-temp-text "<point>P"
          (org-insert-heading)
          (buffer-string))))
#+END_SRC

could be translated like this:

1) in a temporary buffer in org-mode ([[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]]),
2) add the string ~P~ and place the point before ~P~ (~"<point>P"~),
3) call [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]],
4) return the string from the temporary buffer (~buffer-string~),
5) compare this string to the string ~"* P"~ (~equal~),
6) if they are equal, return ~t~, if not, return the error
   ~ert-test-failed~ ([[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]]).

*** Example 3

The third [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] form:

#+BEGIN_SRC emacs-lisp
(should
 (equal "Para\n* graph"
        (org-test-with-temp-text "Para<point>graph"
          (let ((org-M-RET-may-split-line '((default . t))))
            (org-insert-heading))
          (buffer-string))))
#+END_SRC

could be translated like this:

1) in a temporary buffer in org-mode ([[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]]),
2) add the string ~Paragraph~ and place the point between the character ~a~
   and ~g~ (~"Para<point>graph"~),
3) locally set the variable [[org-mode:lisp/org.el::(defcustom org-M-RET-may-split-line][org-M-RET-may-split-line]] to the alist
   ~'((default . t))~ and call [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] with this binding
   (~(let ...)~),
5) return the string from the temporary buffer (~buffer-string~),
6) compare this string to the string ~"Para\n* graph"~ (~equal~ and note
   that ~\n~ is the newline),
7) if they are equal, return ~t~, if not, return the error
   ~ert-test-failed~ ([[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]]).

*** Example 4

The fourth [[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]] form:

#+BEGIN_SRC emacs-lisp
(should
 (equal "Paragraph\n* "
        (org-test-with-temp-text "Para<point>graph"
          (let ((org-M-RET-may-split-line '((default . nil))))
            (org-insert-heading))
          (buffer-string))))
#+END_SRC

could be translated like this:

1) in a temporary buffer in org-mode ([[org-mode:testing/org-test.el::(defmacro org-test-with-temp-text][org-test-with-temp-text]]),
2) add the string ~Paragraph~ and place the point between the character ~a~
   and ~g~ (~"Para<point>graph"~),
3) locally set the variable [[org-mode:lisp/org.el::(defcustom org-M-RET-may-split-line][org-M-RET-may-split-line]] to the alist
   ~'((default . nil))~ and call [[org-mode:lisp/org.el::(defun org-insert-heading][org-insert-heading]] with this binding
   (~(let ...)~),
5) return the string from the temporary buffer (~buffer-string~),
6) compare this string to the string ~"Paragraph\n* "~ (~equal~ and note
   that ~\n~ is the newline),
7) if they are equal, return ~t~, if not, return the error
   ~ert-test-failed~ ([[emacs:lisp/emacs-lisp/ert.el::(cl-defmacro should][should]]).

** Where the truth lives

By now you should be convinced (that's what I hope) that the org-mode
test suite is a gold mine for us (org-mode users) and that is where
part of THE ORG-MODE TRUTH lives.

... More than 5000 examples ...

WE ARE DONE!

* [2022-03-05 Sat] I bet you use hl-line-mode...  Do you know how it works?  Overlays, post-command-hook and only 5 functions!!!
:PROPERTIES:
:CUSTOM_ID: /2022-03-05/i-bet-you-use-hl-line-mode/
:REDDIT_POST: https://www.reddit.com/r/emacs/comments/t7doal/i_bet_you_use_hllinemode_do_you_know_how_it_works/
:END:

Hey Emacsers,

How are you doing?

I'm getting excited about this post because when I understood how
[[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] works, it opened new horizons for me in the world of
Elisp.

I hope you will feel the same way after:

1) reading this post or,
2) by directly reading the source code of [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] that can be
   found in the file [[emacs:lisp/hl-line.el]] (only 205 LOC skipping
   comments and empty lines).

You can get emacs's source code by running the following command:

: git clone git://git.sv.gnu.org/emacs.git

** ~hl-line-mode~
*** What is ~hl-line-mode~?

[[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] is a minor mode that highlights the current line.

If there is multiple windows in your frame using [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] you can
control whether all windows have the line highlighted or only the
~selected-window~ with the option [[emacs:lisp/hl-line.el::(defcustom hl-line-sticky-flag][hl-line-sticky-flag]].

If you prefer not to highlight the whole line but only a range around
the point this is also possible with [[emacs:lisp/hl-line.el::(defvar hl-line-range-function][hl-line-range-function]].

In this post, we are not interested in these options, but only in the
mechanism and the default behavior that highlights the
entire line in the current buffer.

*** How does it work?

[[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] moves an overlay responsible to highlight the current
line after each command call.  This is done by adding a specific
function to the hook [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] when the mode [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] is
turned on.

If you are already familiar with [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] and Emacs overlays,
you're done.

But, if not, let's break things down together.

One things to remember about Emacs ([[info:elisp#Command Loop][info:elisp#Command Loop]]) is:

#+BEGIN_SRC text
When you run Emacs, it enters the “editor command loop” almost
immediately.  This loop reads key sequences, executes their definitions,
and displays the results.
#+END_SRC

Specifically, each time we call a command (inserting a character also
calls a command, [[emacs:src/cmds.c::DEFUN ("self-insert-command",][self-insert-command]] by default), the "editor
command loop":

1) runs the hook [[emacs:src/keyboard.c::  DEFVAR_LISP ("pre-command-hook"][pre-command-hook]] before executing the command,
2) runs the hook [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] after executing the command.

(run the hook ~X~ means: call all the functions in the list ~X~).

So we can trigger actions after each command call by adding
functions in the list [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]].

This is what [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] does.  When turned on, the mode adds the
function [[emacs:lisp/hl-line.el::(defun hl-line-highlight][hl-line-highlight]] to the list [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] as follow:

#+BEGIN_SRC emacs-lisp
(add-hook 'post-command-hook #'hl-line-highlight nil t)
#+END_SRC

Note the ~t~ at the end of the previous s-exp that makes the hook
buffer-local.

So, in a buffer that has [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] turned on, each time we call a
command (basically, "each time we do something"):

1) the command is executed and,
2) [[emacs:lisp/hl-line.el::(defun hl-line-highlight][hl-line-highlight]] is called.

What exactly does [[emacs:lisp/hl-line.el::(defun hl-line-highlight][hl-line-highlight]] do?

[[emacs:lisp/hl-line.el::(defun hl-line-highlight][hl-line-highlight]]:

1) creates an overlay at point with the ~face~ property equal to
   [[emacs:lisp/hl-line.el::(defcustom hl-line-face][hl-line-face]] (calling the function [[emacs:lisp/hl-line.el::(defun hl-line-make-overlay][hl-line-make-overlay]]) if it
   doesn't exist yet,
2) assigns this overlay to the variable [[emacs:lisp/hl-line.el::(defvar-local hl-line-overlay][hl-line-overlay]] and,
3) moves (places) this overlay on the current line (calling the
   function [[emacs:lisp/hl-line.el::(defun hl-line-move][hl-line-move]]).

Here the a snippet of [[emacs:lisp/hl-line.el::(defun hl-line-highlight][hl-line-highlight]] (where I removed some details):

#+BEGIN_SRC emacs-lisp
(defun hl-line-highlight ()
  (if hl-line-mode
      (progn
        (unless (overlayp hl-line-overlay)
          (setq hl-line-overlay (hl-line-make-overlay)))
        ;; ...
        (hl-line-move hl-line-overlay)
        ;; ...
        )
    (hl-line-unhighlight)))
#+END_SRC

The function [[emacs:lisp/hl-line.el::(defun hl-line-make-overlay][hl-line-make-overlay]] uses the function ~make-overlay~ to
make the overlay and uses the function [[emacs:src/buffer.c::DEFUN ("overlay-put"][overlay-put]] to set the ~priority~
and ~face~ property of the new created overlay:

#+BEGIN_SRC emacs-lisp
(defun hl-line-make-overlay ()
  (let ((ol (make-overlay (point) (point))))
    (overlay-put ol 'priority hl-line-overlay-priority)
    (overlay-put ol 'face hl-line-face)
    ol))
#+END_SRC

As we left aside the range function [[emacs:lisp/hl-line.el::(defvar hl-line-range-function][hl-line-range-function]] (which is
set to ~nil~ by default), we can see below a simplified implementation
of [[emacs:lisp/hl-line.el::(defun hl-line-move][hl-line-move]], that we call ~hl-line-move-NO-RANGE-FUNCTION~ that uses
the function [[emacs:src/buffer.c::DEFUN ("move-overlay"][move-overlay]] to move the limits of the overlay and set
them to be the beginning of the current line and beginning of the next
line:

#+BEGIN_SRC emacs-lisp
(defun hl-line-move-NO-RANGE-FUNCTION (overlay)
  (let ((beg (line-beginning-position))
        (end (line-beginning-position 2)))
    (move-overlay overlay beg end)))
#+END_SRC

We have left out some details (the functions [[emacs:lisp/hl-line.el::(defun hl-line-unhighlight][hl-line-unhighlight]]
[[emacs:lisp/hl-line.el::(defun hl-line-maybe-unhighlight][hl-line-maybe-unhighlight]] and the use of the hook
~change-major-mode-hook~), because our goal was to focus on the
mechanism and not all the options and implementation details.

I hope this useful.

*** ~global-hl-line-mode~

[[emacs:lisp/hl-line.el::(define-minor-mode global-hl-line-mode][global-hl-line-mode]] is a global minor mode that offers line
highlighting in all buffers.

The mechanism is "almost" the same as [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] and both
share the functions [[emacs:lisp/hl-line.el::(defun hl-line-make-overlay][hl-line-make-overlay]] and [[emacs:lisp/hl-line.el::(defun hl-line-move][hl-line-move]], the
variables [[emacs:lisp/hl-line.el::(defvar hl-line-overlay-priority][hl-line-overlay-priority]], [[emacs:lisp/hl-line.el::(defvar hl-line-range-function][hl-line-range-function]] and they
use the same "face" [[emacs:lisp/hl-line.el::(defcustom hl-line-face][hl-line-face]].

So, if you understand how [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] works, you already almost
understand how [[emacs:lisp/hl-line.el::(define-minor-mode global-hl-line-mode][global-hl-line-mode]] works.

In the next parts of this post, we build examples using
[[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] and overlays separately to try to get a good
overview of their use.

** Playing with ~pre-command-hook~ and ~post-command-hook~

In this section everything happens in the buffer ~*test hooks*~.

Let's switch to the new buffer ~*test hooks*~ in ~emacs-lisp-mode~
by evaluating the following s-exp in the minibuffer (~M-x
eval-expression~):

#+BEGIN_SRC emacs-lisp
(progn
  (with-current-buffer (get-buffer-create "*test hooks*")
    (emacs-lisp-mode))
  (switch-to-buffer "*test hooks*"))
#+END_SRC

We've already seen that by adding functions to the hooks (lists)
[[emacs:src/keyboard.c::  DEFVAR_LISP ("pre-command-hook"][pre-command-hook]] and [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] we can trigger actions before
or after any command call.

The first things we can do is to inspect the variable
[[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] by running:

: M-x describe-variable RET post-command-hook RET

This will pops up an help buffer that looks like this (the value
depends on the packages you are using):

#+BEGIN_SRC text
post-command-hook is a variable defined in ‘src/keyboard.c’.

Its value is
(jit-lock--antiblink-post-command yas--post-command-handler
eldoc-schedule-timer company-post-command t)
Local in buffer *test hooks*; global value is
(global-font-lock-mode-check-buffers global-eldoc-mode-check-buffers
smartparens-global-mode-check-buffers
show-smartparens-global-mode-check-buffers
yas-global-mode-check-buffers magit-auto-revert-mode-check-buffers
global-hl-line-highlight insight-check-cursor-color
sp--post-command-hook-handler winner-save-old-configurations)

  This variable may be risky if used as a file-local variable.
  Probably introduced at or before Emacs version 19.20.

Normal hook run after each command is executed.
If an unhandled error happens in running this hook,
the function in which the error occurred is unconditionally removed, since
otherwise the error might happen repeatedly and make Emacs nonfunctional.

It is a bad idea to use this hook for expensive processing.  If
unavoidable, wrap your code in ‘(while-no-input (redisplay) CODE)’ to
avoid making Emacs unresponsive while the user types.

See also ‘pre-command-hook’.
#+END_SRC

In this help buffer, we see that the local value in the buffer ~*test
hooks*~ is the list:

: (jit-lock--antiblink-post-command yas--post-command-handler eldoc-schedule-timer company-post-command t)

We also see its global value and the last part of the help buffer is
the docstring of this variable where we can read:

#+BEGIN_SRC text
If an unhandled error happens in running this hook,
the function in which the error occurred is unconditionally removed, since
otherwise the error might happen repeatedly and make Emacs nonfunctional.
#+END_SRC

This tells us that it is safe to play with [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] because if
we add it a function that raises an error the function will be
unconditionally removed.

So let's add to [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] a symbol that has no function
definition (so raises the error ~void-function~ when called as a
function).  So by evaluating the following s-exp (~eval-last-sexp~ bound
to ~C-x C-e~):

#+BEGIN_SRC emacs-lisp
(add-hook 'post-command-hook 'test-void-function)
#+END_SRC

we see in the echo area:

#+BEGIN_SRC text
Error in post-command-hook (test-void-function): (void-function test-void-function)
#+END_SRC

And if we inspect the variable [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] (as we did
previously), we see that ~test-void-function~ symbol isn't in the hook.

What happened?

1) we called ~eval-last-sexp~,
2) then the "editor command loop" ran the hook [[emacs:src/keyboard.c::  DEFVAR_LISP ("pre-command-hook"][pre-command-hook]],
3) then the expression ~(add-hook 'post-command-hook 'test-void-function)~
   has been evaluated, which added ~test-void-function~ symbol to
   [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]],
4) then the "editor command loop" ran the hook [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]], and
   when it try to call the function ~test-void-function~, it raised the
   error ~void-function~ and remove ~test-void-function~ from the hook.

Now that we are confident that playing with the hook
[[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] won't break our running Emacs, let's build the main
example of this section.

We write 2 functions ~test-hook-pre~ and ~test-hook-post~
that print out respectively the name of the command that is about to
run and the name of the command that just ran.

To do that we use the emacs variable [[emacs:src/keyboard.c::    DEFVAR_LISP ("this-command"][this-command]] (that holds the
command now being executed) and adds ~test-hook-pre~ to [[emacs:src/keyboard.c::  DEFVAR_LISP ("pre-command-hook"][pre-command-hook]]
and ~test-hook-post~ to [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]].

Note that the info nodes related to this examples are:

- [[info:elisp#Command Overview]]
- [[info:elisp#Command Loop Info]]

Then we call some commands.

And finally we observe what has been printed out in the buffer
~*Messages*~.

In the buffer ~*test hooks*~, we remove everything and add the following
expressions:

#+BEGIN_SRC emacs-lisp
(defun test-hook-pre ()
  (message "  BEFORE   |   %s" this-command))

(defun test-hook-post ()
  (message "   AFTER   |   %s" this-command))

(add-hook 'pre-command-hook 'test-hook-pre)
(add-hook 'post-command-hook 'test-hook-post)

(message ":::::::: print me ::::::::")
#+END_SRC

Then with the point after the last s-exp (last parenthesis), we do in
order (without doing anything else, this is important for the messages
we want to see printed):

1) ~M-x eval-buffer~ (this evaluate all this expressions),
2) ~C-a~ (move to the beginning),
3) ~C-e~ (move to the end of line),
4) ~C-x C-e~ (eval the last expression).

Then, we should see in the buffer (almost at the end) ~*Messages*~ the
following:

#+BEGIN_SRC text
:::::::: print me ::::::::
   AFTER   |   eval-buffer
  BEFORE   |   move-beginning-of-line
   AFTER   |   move-beginning-of-line
  BEFORE   |   move-end-of-line
   AFTER   |   move-end-of-line
  BEFORE   |   eval-last-sexp
:::::::: print me ::::::::
":::::::: print me ::::::::"
   AFTER   |   eval-last-sexp
#+END_SRC

This gives us an overview of the behavior of the "editor command
loop".

Are you annoyed by the noise you have in your echo area?

Me too.

Let's remove the functions ~test-hook-pre~ and ~test-hook-post~
respectively from the hooks [[emacs:src/keyboard.c::  DEFVAR_LISP ("pre-command-hook"][pre-command-hook]] and [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]] by
evaluating the following s-exps.  This should "clean up" our echo
area.

#+BEGIN_SRC emacs-lisp
(remove-hook 'pre-command-hook 'test-hook-pre)
(remove-hook 'post-command-hook 'test-hook-post)
#+END_SRC

We are done with the hooks [[emacs:src/keyboard.c::  DEFVAR_LISP ("pre-command-hook"][pre-command-hook]] and [[emacs:src/keyboard.c::  DEFVAR_LISP ("post-command-hook"][post-command-hook]].
Let's play with overlays.

** Moving overlays and priorities

In the post [[#/2022-02-26/org-mode-visibility-of-headings/][Have you ever wondered how org-mode toggles the visibility
of headings?]], we already played with overlays specifically the ~invisible~
property of overlay.  We also know that overlays take priority over
text properties.

Here, we see:

1) how to move overlays ([[emacs:src/buffer.c::DEFUN ("move-overlay"][move-overlay]]) and,
2) which overlay wins when they overlap (~priority~ property).

Note that all the evaluations of the s-expressions are done in the
minibuffer with ~M-x eval-expression~ and the point in the buffer we
operate on, that we call ~*overlays*~.

Let's switch to the new buffer ~*overlays*~ in ~fundamental-mode~
by evaluating the following s-exp:

#+BEGIN_SRC emacs-lisp
(switch-to-buffer (get-buffer-create "*overlays*"))
#+END_SRC

Let's insert the characters ~FOO---BAR---BAZ~ such that the buffer
~*overlays*~ look likes this:

#+BEGIN_SRC text
FOO---BAR---BAZ
#+END_SRC

We make two overlays:

1) ~ov-x~ on top of ~FOO~ with a background green (~#00ff00~),
2) ~ov-y~ on top of ~BAZ~ with a background red (~#ff0000~).

To do so, we evaluate the following form:

#+BEGIN_SRC emacs-lisp
(progn
  (setq ov-x (make-overlay 1 4))
  (overlay-put ov-x 'face '(:background "#00ff00"))
  (setq ov-y (make-overlay 13 16))
  (overlay-put ov-y 'face '(:background "#ff0000")))
#+END_SRC

Now we have ~FOO~ with a background green and ~BAZ~ with a background
red.

Let's move the overlay ~ov-x~ (the green) on top of the characters ~BAR~
the same way [[emacs:lisp/hl-line.el::(define-minor-mode hl-line-mode][hl-line-mode]] does.  To do so we use the function
[[emacs:src/buffer.c::DEFUN ("move-overlay"][move-overlay]] as follow:

#+BEGIN_SRC emacs-lisp
(move-overlay ov-x 7 10)
#+END_SRC

When more than one overlay overlap, Emacs decides for each property,
which overlay "wins" (see [[info:elisp#Overlay
Properties][info:elisp#Overlay Properties]]) over the
others by looking up at the overlay property ~priority~ which should be
a positive integer or ~nil~, thought the higher value "wins".

Let's see this on our example.

First, we set the overlay ~ov-x~ to have a ~priority~ equal to ~10~ and the
overlay ~ov-y~ to have a priority equal to ~20~ by evaluating the
following form:

#+BEGIN_SRC emacs-lisp
(progn
  (overlay-put ov-x 'priority 10)
  (overlay-put ov-y 'priority 20))
#+END_SRC

Now we move the overlay ~ov-y~ to be on top of the characters ~BAR~ (and so
overlap with the overlay ~ov-x~) by evaluating this s-exp:

#+BEGIN_SRC emacs-lisp
(move-overlay ov-y 7 10)
#+END_SRC

The buffer ~*overlays*~ shows the characters ~BAR~ with a background red
that corresponds to the overlay ~ov-y~ which have a priority ~20~ superior
to the priority ~10~ of the overlay ~ov-x~.

Now let's make ~ov-x~ wins by raising its priority to ~30~:

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'priority 30)
#+END_SRC

ISN'T IT SUPER COOL!!!

Something interesting we can do now is to ~M-x describe-char~, with the
point between ~A~ and ~R~ in the word ~BAR~, which pops up the following
help buffer:

#+BEGIN_SRC text
             position: 9 of 15 (53%), column: 8
            character: R (displayed as R) (codepoint 82, #o122, #x52)
              charset: ascii (ASCII (ISO646 IRV))
code point in charset: 0x52
               script: latin
               syntax: w 	which means: word
             category: .:Base, L:Left-to-right (strong), a:ASCII, l:Latin, r:Roman
             to input: type "C-x 8 RET 52" or "C-x 8 RET LATIN CAPITAL LETTER R"
          buffer code: #x52
            file code: #x52 (encoded by coding system utf-8-unix)
              display: by this font (glyph code)
    ftcrhb:-PfEd-DejaVu Sans Mono-normal-normal-normal-*-15-*-*-*-m-0-iso10646-1 (#x35)

Character code properties: customize what to show
  name: LATIN CAPITAL LETTER R
  general-category: Lu (Letter, Uppercase)
  decomposition: (82) ('R')

There are 2 overlays here:
 From 7 to 10
  face                 (:background "#00ff00")
  priority             30
 From 7 to 10
  face                 (:background "#ff0000")
  priority             20
#+END_SRC

Note that it might differs in your running emacs (different fonts,
maybe information about overlays if you are using ~hl-line-mode~, ...).

There are 2 overlays!!!

To finish this post, we remove the overlays like this:

#+BEGIN_SRC emacs-lisp
(remove-overlays)
#+END_SRC

WE ARE DONE!!!

* [2022-02-26 Sat] Have you ever wondered how org-mode toggles the visibility of headings?
:PROPERTIES:
:CUSTOM_ID: /2022-02-26/org-mode-visibility-of-headings/
:REDDIT_POST: https://www.reddit.com/r/emacs/comments/t1r2wq/have_you_ever_wondered_how_orgmode_toggles_the/
:END:

Have you ever wondered how org-mode toggles the visibility of headings?

YES!!!  me either!

Let's get into it ;)

** org-mode visibility of headings

~org-mode~ is built on top of ~outline-mode~ that is responsible of the
visibility changes of the headings.

How does it work?

~outline-mode~ uses overlays, specifically the overlay property
~invisible~ to toggle the visibility of the headings:

1) To hide the body of a heading, ~outline-mode~ makes an overlay from
   the end of the line of the heading to the end of the body of the
   heading, and set the property ~invisible~ of the overlay to be the
   symbol ~outline~.  Hence, the part of the buffer with this overlay
   is "replaced" (visually, not the content of the buffer) by
   ellipsis.  Why is this?  Because, when ~outline-mode~ is turned
   on, it adds the cons ~(outline . t)~ to the variable
   ~buffer-invisibility-spec~ which became buffer local and is
   responsible for the invisibility of each buffer.
2) To make visible the body of a heading, ~outline-mode~ removes any
   overlays in the body of the heading that have its property
   ~invisible~ set to the symbol ~outline~.

To see exactly how this is achieved you can refer to the functions
[[emacs:lisp/outline.el::(defun outline-flag-region][outline-flag-region]], [[emacs:lisp/outline.el::(defun outline-hide-entry][outline-hide-entry]] and [[emacs:lisp/outline.el::(defun outline-show-entry][outline-show-entry]] defined
in the file [[emacs:lisp/outline.el]] and also the definition of the mode
[[emacs:lisp/outline.el::(define-derived-mode outline-mode][outline-mode]] in the same file.

You can get emacs's source code by running the following command:

: git clone git://git.sv.gnu.org/emacs.git

OK!

The mechanism of ~outline-mode~ uses overlays, [[emacs:src/buffer.c::DEFVAR_PER_BUFFER ("buffer-invisibility-spec"][buffer-invisibility-spec]]
and ellipsis.

But how do those "emacs/elisp features" play together?

In the next parts of this post, we build examples using them to try to
get a good feel for their use.

** text properties

In a buffer, each character point can have text properties attached to
it that can be used to do many things (like controling the appearance
of the character).

For instance, in an ~emacs-lisp-mode~ buffer, with the following s-exp,
and the cursor (the point) after the first parenthesis:

#+BEGIN_SRC emacs-lisp
(setq my-var nil)
#+END_SRC

if we run:

: M-x eval-expression RET (text-properties-at (point))

we get:

#+BEGIN_SRC emacs-lisp
(face font-lock-keyword-face fontified t)
#+END_SRC

The character point "s" (point 2, i.e. the "s" at the second position
in the buffer) has:

1) the text property ~face~ equal to the face [[emacs:lisp/font-lock.el::(defface font-lock-keyword-face][font-lock-keyword-face]]
   which is why it is display with a different foreground color
   (depending on your theme) than the text ~my-var~ for instance,
2) the text property ~fontified~ equal to ~t~ which we don't describe
   here.

We can read more about the special text properties in the manual
([[info:elisp#Special Properties]]).

If we want more information (not only the text properties) about the
character point "s" (point 2), we can run (still with with the cursor
after the first parenthesis):

: M-x describe-char

which pops up the following help buffer:

#+BEGIN_SRC text
             position: 2 of 18 (6%), column: 1
            character: s (displayed as s) (codepoint 115, #o163, #x73)
              charset: ascii (ASCII (ISO646 IRV))
code point in charset: 0x73
               script: latin
               syntax: w 	which means: word
             category: .:Base, L:Left-to-right (strong), a:ASCII, l:Latin, r:Roman
             to input: type "C-x 8 RET 73" or "C-x 8 RET LATIN SMALL LETTER S"
          buffer code: #x73
            file code: #x73 (encoded by coding system prefer-utf-8-unix)
              display: by this font (glyph code)
    ftcrhb:-PfEd-DejaVu Sans Mono-normal-normal-normal-*-15-*-*-*-m-0-iso10646-1 (#x56)

Character code properties: customize what to show
  name: LATIN SMALL LETTER S
  general-category: Ll (Letter, Lowercase)
  decomposition: (115) ('s')

There are text properties here:
  face                 font-lock-keyword-face
  fontified            t
#+END_SRC

Note that it might differs in your running emacs (different fonts,
maybe information about overlays if you are using ~hl-line-mode~, ...).

** Why are we talking about text properties if the mechanism of ~outline-mode~ uses overlays?

Because:

1) Both text properties and overlays can "alter/control" the
   appearance of the buffer's text on the screen and so we have to
   know something important that is (from the manual
   [[info:elisp#Overlay Properties]]):

   #+BEGIN_SRC text
   all overlays take priority over text properties.
   #+END_SRC

2) buffer invisibility can also be achieve with text property (for
   instance, this is what ~org-mode~ does to hide the brackets and the
   link part of links like this ~[[link][description]]~), and it is
   important to notice it.

** overlays, invisible overlay property, buffer-invisibility-spec

We can make a part of a buffer invisible using:

1) the ~invisible~ text property (of that part),
2) the ~invisible~ overlay property ("on top of that part").

The "admitted" values of the ~invisible~ overlay property (or text
property) and the invisibility effect expected depend on the value of
the variable [[emacs:src/buffer.c::DEFVAR_PER_BUFFER ("buffer-invisibility-spec"][buffer-invisibility-spec]].

In this section:

1) we define overlays,
2) we set the variable ~buffer-invisibility-spec~,
3) we give different values to the ~invisible~ property of the overlays,
4) we observe the appearance of the buffer,
5) we repeat several times step 2) to 4).
6) we hope we get a good feeling of invisibility in Emacs.

Also note that all the evaluations of the s-expressions are done in the
minibuffer with ~M-x eval-expression~ and the point in the buffer we
operate on, that we call ~*invisible*~.

Let's switch to the new "fresh" buffer ~*invisible*~ in ~fundamental-mode~
by evaluating the following s-exp:

#+BEGIN_SRC emacs-lisp
(switch-to-buffer (get-buffer-create "*invisible*"))
#+END_SRC

Let's insert the characters ~XXXXXX~ at the beginning of the buffer
~*invisible*~:

#+BEGIN_SRC text
XXXXXX
#+END_SRC

*** ~buffer-invisibility-spec~ equal to ~t~

Now if we evaluate the variable ~buffer-invisibility-spec~, we should
get ~t~ (the default) in the echo area.

If not, we set this variable to ~t~ like this:

#+BEGIN_SRC emacs-lisp
(setq buffer-invisibility-spec t)
#+END_SRC

Now, we make an overlay "on top" of ~XXXXXX~ (from point 1 to point 7 in
the buffer) that we assign to the variable ~ov-x~ using [[emacs:src/buffer.c::DEFUN ("make-overlay"][make-overlay]]:

#+BEGIN_SRC emacs-lisp
(setq ov-x (make-overlay 1 7))
#+END_SRC

and we see the following in the echo area:

#+BEGIN_SRC text
#<overlay from 1 to 7 in *invisible*>
#+END_SRC

Now, by setting the property ~invisible~ of the overlay ~ov-x~ to ~t~ using
the function  [[emacs:src/buffer.c::DEFUN ("overlay-put"][overlay-put]] like this

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'invisible t)
#+END_SRC

we make the characters ~XXXXXX~ disappear.

This is due to the value of ~buffer-invisibility-spec~ equal to ~t~ (the
default) which means that text is invisible if it has a non-nil
~invisible~ (text or overlay) property.

Now, evaluating the following s-exp sets ~invisible~ property of
the overlay ~ov-x~ to ~nil~

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'invisible nil)
#+END_SRC

makes the characters ~XXXXXX~ to reappear in the buffer ~*invisible*~.

We also could have removed the overlay ~ov-x~ to make the characters
~XXXXXX~ to reappear.  Let's see how.

First, as previously, we set the ~invisible~ property of the overlay
~ov-x~ to ~t~ to make the characters ~XXXXXX~ to disappear:

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'invisible t)
#+END_SRC

Then, instead of setting back the ~invisible~ overlay property to ~nil~ of
~ov-x~ we remove it.  To do so, we use the function [[emacs:lisp/subr.el::(defun remove-overlays][remove-overlays]] that
let you remove all the overlays in a range of the buffer that have a
specific property set to some value (in our case the property ~invisible~
set to ~t~ in the range 1 to 7 of the buffer).

So evaluating the following s-exp

#+BEGIN_SRC emacs-lisp
(remove-overlays 1 7 'invisible t)
#+END_SRC

removes the overlay ~ov-x~ in the buffer ~*invisible*~ and make the
characters ~XXXXXX~ to reappear.

*** ~buffer-invisibility-spec~ equal to ~nil~

As we removed the overlay ~ov-x~, we redifined it as previously by
evaluating the following s-exp:

#+BEGIN_SRC emacs-lisp
(setq ov-x (make-overlay 1 7))
#+END_SRC

Let's set ~buffer-invisibility-spec~ to ~nil~:

#+BEGIN_SRC emacs-lisp
(setq buffer-invisibility-spec nil)
#+END_SRC

Then, by evaluating the following s-exp, we expect the characters
~XXXXXX~ to disappear:

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'invisible t)
#+END_SRC

BUT they don't.

This is normal, as we've just set ~buffer-invisibility-spec~ to ~nil~,
we've "disabled" the invisibility feature in the buffer ~*invisible*~.

Now, we restore the ~invisible~ property of the overlay ~ov-x~ so as not to
interfere with the next example by evaluating:

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'invisible nil)
#+END_SRC

*** ~buffer-invisibility-spec~ equal to ~((foo) t)~

Let's add the characters ~YYYYYY~ after the characters ~XXXXXX~ with
3 dashes ~---~ in between such that the buffer ~*invisible*~ is now:

#+BEGIN_SRC text
XXXXXX---YYYYYY
#+END_SRC

Now, we make an overlay "on top" of ~YYYYYY~ (from point 10 to point 16
in the buffer) that we assign to the variable ~ov-y~ using ~make-overlay~:

#+BEGIN_SRC emacs-lisp
(setq ov-y (make-overlay 10 16))
#+END_SRC

We set back ~buffer-invisibility-spec~ to ~t~ (the default):

#+BEGIN_SRC emacs-lisp
(setq buffer-invisibility-spec t)
#+END_SRC

Then we add the list ~(foo)~ to the variable ~buffer-invisibility-spec~
using the function [[emacs:lisp/subr.el::(defun add-to-invisibility-spec][add-to-invisibility-spec]] as follow:

#+BEGIN_SRC emacs-lisp
(add-to-invisibility-spec '(foo))
#+END_SRC

Now, the value of ~buffer-invisibility-spec~ is ~((foo) t)~.

This implies that, now to make a part of the buffer invisible, the
~invisible~ property must be ~foo~ or ~t~.  Before, it could have been any
value that is non-nil.

This way we can toggle the visibility of some parts of the buffer
while other parts remain invisible (see [[org-mode:lisp/ol.el::(defun org-toggle-link-display][org-toggle-link-display]] for
instance).

Let's make ~XXXXXX~ disappear "permanently" by setting the ~invisible~
property of ~ov-x~ to ~t~:

#+BEGIN_SRC emacs-lisp
(overlay-put ov-x 'invisible t)
#+END_SRC

The characters ~XXXXXX~ disappear and the buffer ~*invisible*~ is now:

#+BEGIN_SRC text
---YYYYYY
#+END_SRC

Now, we set the ~invisible~ property of ~ov-y~ to be equal to ~foo~:

#+BEGIN_SRC emacs-lisp
(overlay-put ov-y 'invisible 'foo)
#+END_SRC

The characters ~YYYYYY~ disappear and the buffer ~*invisible*~ is now:

#+BEGIN_SRC text
---
#+END_SRC

Now, what we can do is to make ~YYYYYY~ appears again by removing ~(foo)~
from the invisibility spec ~buffer-invisibility-spec~ while the
characters ~XXXXXX~ stay invisible:

#+BEGIN_SRC emacs-lisp
(remove-from-invisibility-spec '(foo))
#+END_SRC

Now, the buffer ~*invisible*~ is:

#+BEGIN_SRC text
---YYYYYY
#+END_SRC

Note that:

1) the overlay ~ov-x~ still has its property ~invisible~ equal to ~t~ and,
2) the overlay ~ov-y~ still has its property ~invisible~ equal to ~foo~.

You can verify it by evaluating the following s-exp:

#+BEGIN_SRC emacs-lisp
(overlay-get ov-x 'invisible) ; t
(overlay-get ov-y 'invisible) ; foo
#+END_SRC

** ellipsis and ~buffer-invisibility-spec~ equal to ~((foo . t) t)~
*** default ellipsis ~...~

If the variable ~buffer-invisibility-spec~ as a list contains a cons
~(foo . t)~, every continuous part of the buffer with the ~invisible~
property set to ~foo~ is replaced by ellipsis which are by default ~...~.

The buffer ~*invisible*~ still contains the characters ~XXXXXX---YYYYYY~,
but maybe not all the characters are visible.  So let's put our buffer
in an appropriate state for this section.

We removes all the overlays in the buffer (which makes all the content
of the buffer visible again).  We redifined the ~ov-x~ and ~ov-y~ as
previously (same part of the buffer (1 to 7) and (10 to 16)).  And we
set ~buffer-invisibility-spec~ to be ~((foo . t) t)~.  We can do this by
evaluating the following expression (in the minibuffer with point in
the buffer ~*invisible*~):

#+BEGIN_SRC emacs-lisp
(progn
  (remove-overlays)
  (setq ov-x (make-overlay 1 7))
  (setq ov-y (make-overlay 10 16))
  (setq buffer-invisibility-spec t)
  (add-to-invisibility-spec '(foo . t)))
#+END_SRC

The buffer ~*invisible*~ is now:

#+BEGIN_SRC text
XXXXXX---YYYYYY
#+END_SRC

By evaluating the following s-exp, we set the ~invisible~ property
of the overlay ~ov-y~ to ~foo~

#+BEGIN_SRC emacs-lisp
(overlay-put ov-y 'invisible 'foo)
#+END_SRC

and this replaces (visually not the content of the buffer) the
characters ~YYYYYY~ by the default ellipsis ~...~ and the buffer
~*invisible*~ looks like this:

#+BEGIN_SRC text
XXXXXX---...
#+END_SRC

*** custom ellipsis modifying the display table

We assume with the buffer ~*invisible*~ is in the same state as in the
previous section.

Our goal in this section is to modify the default ellipsis ~...~.

To do so we:

1) create a display table with the function [[emacs:lisp/disp-table.el::(defun make-display-table][make-display-table]],
2) we set its special slot 4 (responsible of the display of the
   ellipsis) which must be a vector of glyph using the function
   [[emacs:lisp/disp-table.el::(defun set-display-table-slot][set-display-table-slot]],
3) we set the variable [[emacs:src/buffer.c::  DEFVAR_PER_BUFFER ("buffer-display-table"][buffer-display-table]] of the buffer ~*invisible*~
   to be this new display table,
4) we observe the appearance of the buffer ~*invisible*~.

So by evaluating the following s-exp:

#+BEGIN_SRC emacs-lisp
(let ((tbl (make-display-table))
      (glyph-vector
       (vector (make-glyph-code ?\ 'font-lock-warning-face)
               (make-glyph-code ?\; 'font-lock-warning-face)
               (make-glyph-code ?- 'font-lock-warning-face)
               (make-glyph-code ?\) 'font-lock-warning-face))))
  (set-display-table-slot tbl 4 glyph-vector)
  (setq buffer-display-table tbl))
#+END_SRC

the buffer ~*invisible*~ should looks like this (if the ~invisible~
property of the overlay ~ov-y~ is still equal to ~foo~):

#+BEGIN_SRC text
XXXXXX--- ;-)
#+END_SRC

You can read more about character display and display table in the
manual ([[info:elisp#Character Display]]).

WE ARE DONE :-)

* [2022-02-20 Sun] You want to write a custom org backend?  Let's write onlybold backend together to get you started
:PROPERTIES:
:CUSTOM_ID: /2022-02-20/onlybold-org-backend/
:REDDIT_POST: https://www.reddit.com/r/emacs/comments/swvbmm/you_want_to_write_a_custom_org_backend_lets_write/
:END:

Hi Emacsers,

recently I've been playing with ~org-element~ and ~org-export~.

Specifically, I was interested in the mechanism of the org exporter
system and its flexibility.

The goal of this post is to get you started with the creation of org
backends.

To do so, we build an org backend that:

1) keeps only ~bold~ elements,
2) surrounds ~bold~ elements with ~***~ before and after,
3) surrounds ~paragraph~ elements with ~::~ before and after,
4) surrounds ~section~ elements with ~<--~ before and ~-->~ after (removing
   the last newline).

We call it ~onlybold~.

Before, we start, if you are interested, I recommend you to read in
org-mode's source code the following files:

- [[org-mode:lisp/ox.el]],
- [[org-mode:lisp/ox-html.el]],
- [[org-mode:lisp/ox-md.el]],
- [[org-mode:lisp/ox-org.el]],
- [[org-mode:testing/lisp/test-ox.el]] (AMAZING).

You can get org-mode's source code by running the following command:

: git clone https://git.savannah.gnu.org/git/emacs/org-mode.git

Let's get started.

** what we want to achieve

We want to export this org buffer:

#+BEGIN_SRC org
I like *bold-1* and *bold-2* and you?
I don't.  I prefer *bold-3*.


I've loved *bold-4* since I was a child.

I'm /italic/.
#+END_SRC

into another buffer like this:

#+BEGIN_SRC text
<--::***bold-1*** ***bold-2*** ***bold-3***::


::***bold-4*** ::-->
#+END_SRC

** org export mechanism

When org exports an org buffer, basically it does two things:

1) parse the org buffer producing a tree (a nested elisp list)
   representing the org buffer and,
2) recursively build a string by traversing the tree and choosing for
   each node what to do with it by looking up for its associated
   transcode function defined by the org backend.

It means that *org* does the *hard work* for us "parsing" and
"traversing".

To build ~onlybold~ org backend and any other org backends, in the
simplest case, we just have to provide the *transcode functions*
(or simply *transcoders*).

** transcoders, org-export-define-backend and org-export-to-buffer

The function [[org-mode:lisp/ox.el::(defun org-export-define-backend][org-export-define-backend]] takes as arguments:

1) the backend's name we want to define and
2) an alist of transcoders.

A *transcoder* (or a transcode function), is a function that handles an
org element when it is being exported.

For instance, our backend ~onlybold~ must define a transcoder for ~bold~
elements that surrounds bold texts with 3 stars ~***~ like this:

: bold text -> ***bold text***

Most transcoders take three arguments:

1) the element as it appears in the parsed tree,
2) a content strings corresponding to the children of the element
   already "transcoded",
3) the communication channel that contains all the information the
   export system needs to export correctly the document (the obvious
   ones are the title, date and author of the document that can be
   defined inside the document using lines starting by ~#+TITLE:~,
   ~#+DATE:~ or ~#+AUTHOR~).

Let's define ~onlybold-bold~, the transcoder of ~bold~ elements:

#+BEGIN_SRC emacs-lisp
(defun onlybold-bold (bold contents info)
  (concat "***" contents "***"))
#+END_SRC

Now, we can define the first version of ~onlybold~ backend, which
transcodes only ~bold~ elements:

#+BEGIN_SRC emacs-lisp
(org-export-define-backend 'onlybold
  '((bold . onlybold-bold)))
#+END_SRC

Then we defined the command ~onlybold-export~ that pops up the buffer
~*onlybold*~ which contains the exported content (using ~onlybold~
backend) of the current buffer:

#+BEGIN_SRC emacs-lisp
(defun onlybold-export ()
  (interactive)
  (org-export-to-buffer 'onlybold "*onlybold*"))
#+END_SRC

Now, if we call the command ~onlybold-export~ inside our org buffer,
the buffer ~*onlybold*~ pops up with *nothing* in it.

We might be disappointed, but we aren't.  This is totally normal.

In a specific backend, when an element doesn't have a transcoder to
handle it, the element is skipped.  (In the same vain, if a transcoder
return ~nil~ for an element, the element is also skipped).

** parsed tree, section elements and paragraph elements

In our org buffer, the bold elements belong to paragraphs that belongs
to a section as we can see by looking at the parsed tree in the buffer
~*Pp Eval Output*~ after running the following command (being in the org
buffer):

: M-x pp-eval-expression RET (org-element-parse-buffer)

We get the following tree (where we cut off and replace by ~...~
informations that are not related to the shape of the tree):

#+BEGIN_SRC emacs-lisp
(org-data
 nil
 (section
  (...)
  (paragraph
   (...)
   #("I like " ...)
   (bold
    (...)
    #("bold-1" ...))
   #("and " ...)
   (bold
    (...)
    #("bold-2" ...))
   #("and you?\nI don't.  I prefer " ...)
   (bold
    (...)
    #("bold-3" ...))
   #(".\n" ...))
  (paragraph
   (...)
   #("I've loved " ...)
   (bold
    (...)
    #("bold-4" ...))
   #("since I was a child.\n" ...))
  (paragraph
   (...)
   #("I'm " ...)
   (italic
    (...)
    #("italic" ...))
   #("." ...))))
#+END_SRC

Indeed, ~bold~ elements belong to ~paragraph~ elements that belong to a
~section~ element.

And as we have just seen, if a backend doesn't provide a transcoder
for an element, this element will be ignored in the exported result.

So let's write ~onlybold-section~, the transcoder of ~section~ elements
which surrounds their content with ~<--~ and ~-->~:

#+BEGIN_SRC emacs-lisp
(defun onlybold-section (section contents info)
  (concat "<--" contents "-->"))
#+END_SRC

and ~onlybold-paragraph~, the transcoder of ~paragraph~ elements
which surrounds their content with ~::~:

#+BEGIN_SRC emacs-lisp
(defun onlybold-paragraph (paragraph contents info)
  (concat "::" contents "::"))
#+END_SRC

Then, we modify ~onlybold~ backend like this:

#+BEGIN_SRC emacs-lisp
(org-export-define-backend 'onlybold
  '((bold . onlybold-bold)
    (section . onlybold-section)
    (paragraph . onlybold-paragraph)))
#+END_SRC

Now, if we call the command ~onlybold-export~ inside our org buffer,
the buffer ~*onlybold*~ pops up with this content:

#+BEGIN_SRC text
<--::I like ***bold-1*** and ***bold-2*** and you?
I don't.  I prefer ***bold-3***.
::


::I've loved ***bold-4*** since I was a child.
::

::I'm .
::
-->
#+END_SRC

This is better:

1) The ~bold~ elements has been transcoded as we expected,
2) The "normal" text remains the same as in our org buffer and,
3) note that the ~italic~ element has been ignored (which was expected
   because we didn't provide a transcoder for ~italic~ elements).

** only keep bold elements

~plain-text~ elements are the leaves of the parsed tree, they are
strings.  And to keep only ~bold~ elements, this is the right level to
operate.

So now, let's handle the ~plain-text~ elements and keep only ~bold~
elements.

There is a least two ways to do it:

1) using the filter system provided by the org export system (and so
   provided a filter that applies to ~plain-text~ elements) or,
2) providing a specific transcoder for ~plain-text~ elements.

We implement the later.

Let's write the transcoder ~onlybold-plain-text~ which checks if the
*parent* of the ~plain-text~ element (the string) is a ~bold~ element.  If
this is the case, we return the string and if not we return ~nil~:

#+BEGIN_SRC emacs-lisp
(defun onlybold-plain-text (text info)
  (when (eq 'bold (org-element-type (org-element-property :parent text)))
    text))
#+END_SRC

Note that the arity (number of arguments) of ~onlybold-plain-text~ is
different from the transcoders that we've seen so far.

Then we add it to ~onlybold~ backend:

#+BEGIN_SRC emacs-lisp
(org-export-define-backend 'onlybold
  '((bold . onlybold-bold)
    (section . onlybold-section)
    (paragraph . onlybold-paragraph)
    (plain-text . onlybold-plain-text)))
#+END_SRC

Now, if we call the command ~onlybold-export~ inside our org buffer,
the buffer ~*onlybold*~ pops up with this content:

#+BEGIN_SRC text
<--::***bold-1*** ***bold-2*** ***bold-3***::


::***bold-4*** ::

::::
-->
#+END_SRC

We have filtered the text to keep only ~bold~ elements.

** remove empty paragraphs and the last newline of the section

Let's go further and remove the last empty paragraph.

To do so, we can "ask" the transcoder ~onlybold-paragraph~ to return ~nil~
when its contents is "empty", specifically when its content is the
empty strings ~""~ or a newline ~"\n"~.  Here is the new implementation:

#+BEGIN_SRC emacs-lisp
(defun onlybold-paragraph (paragraph contents info)
  (if (member contents '("" "\n"))
      nil
    (concat "::" contents "::")))
#+END_SRC

Now, if we call the command ~onlybold-export~ inside our org buffer,
the buffer ~*onlybold*~ pops up with this content:

#+BEGIN_SRC text
<--::***bold-1*** ***bold-2*** ***bold-3***::


::***bold-4*** ::
-->
#+END_SRC

We are almost happy :)

Only one thing remains...

The end of the section ~-->~ alone in the last line is "quite ugly".

Let's put it just after ~::~ that close the last paragraph.

We can do this by modifying ~onlybold-section~ and "asking" it to
remove the last newline of its content which is matched by the regexp
~"\n\\'"~:

#+BEGIN_SRC emacs-lisp
(defun onlybold-section (section contents info)
  (let ((cts (replace-regexp-in-string "\n\\'" "" contents)))
    (concat "<--" cts "-->")))
#+END_SRC

Now, if we call the command ~onlybold-export~ inside our org buffer,
the buffer ~*onlybold*~ pops up with this content:

#+BEGIN_SRC text
<--::***bold-1*** ***bold-2*** ***bold-3***::


::***bold-4*** ::-->
#+END_SRC

We are done ;)

I hope that this toy example helps you get started with the creation
of org backends

** acknowledgments

I take the opportunity of this post to thank:

1) Nicolas Goaziou who is the author and maintainer of
   [[org-mode:lisp/ox.el]], and [[org-mode:lisp/org-element.el]].
2) All the people who work and contribute to org-mode (built-in and
   external packages),
3) All the people who work and contribute to Emacs (built-in and
   external packages).

And I want to tell you that:

Each time a piece of your code is heavy, I know that:

1) this piece of code fixes a bug or,
2) this piece of code handles an edge case or,
3) this piece of code provides flexibility (via options) to the end
   user.

Each time your code is simple, I know that you worked hard to make
it simple.

And the more important, each time I read a piece of your code I feel
closer to you.

Emacs is pure joy and it is thanks to you.

* [2022-02-11 Fri] Some examples on closures and lexical-binding
:PROPERTIES:
:CUSTOM_ID: /2022-02-11/closures-and-lexical-binding/
:REDDIT_POST: https://www.reddit.com/r/emacs/comments/sq1esz/some_examples_on_closures_and_lexicalbinding/
:END:

Hi Emacsers,

I've spent some time learning Elisp closures and lexical binding.

Although the documentation is clear with simple examples, I needed to
to play with other examples to get my bearings.

As you might be interested, I share them with you :)

The first section contains the info nodes and help corresponding to
the examples.

The second section shows 10 "basic" examples using [[emacs:src/lread.c::  DEFVAR_LISP ("lexical-binding"][lexical-binding]],
[[emacs:lisp/subr.el::(defmacro
lambda][lambda]], [[emacs:lisp/emacs-lisp/byte-run.el::(defmacro defun][defun]], [[emacs:src/eval.c::DEFUN ("let"][let]], [[emacs:lisp/obsolete/cl.el::(defmacro lexical-let][lexical-let]], [[emacs:src/eval.c::DEFUN ("setq"][setq]] and [[emacs:src/eval.c::DEFUN ("defvar"][defvar]].

And the third section shows a more advanced example using [[emacs:lisp/subr.el::(defmacro lambda][lambda]], [[emacs:src/eval.c::DEFUN ("let"][let]],
[[emacs:lisp/subr.el::(defmacro
dolist][dolist]] and [[emacs:lisp/emacs-lisp/byte-run.el::(defmacro defun][defun]].

Have a nice day,

ps: In the documentation, we can read "Lexical binding is also more
compatible with concurrency, which was added to Emacs in version
26.1.".

Is someone know why is this?  And can you indicate me the
files in the emacs source code where I can see this benefits?  I'm
really curious... thank you.

** info and help

Info nodes:

- ~M-x eval-expression RET (info "(elisp)Variable Scoping")~
- ~M-x eval-expression RET (info "(elisp)Closures")~

help:

- ~C-h v lexical-binding~
- ~C-h f defvar~
- ~C-h f lambda~
- ~C-h f lexical-let~

** 10 examples with lexical-binding, lambda, defun, let, lexical-let, setq, defvar

- example 1

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding nil)
  (lambda (x) (* x x)) ; (lambda (x) (* x x))
  #+END_SRC

- example 2

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)
  (lambda (x) (* x x)) ; (closure (t) (x) (* x x))
  #+END_SRC

- example 3

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding nil)
  (let ((x 1)) (lambda (y) (+ x y)))
  ;; (lambda (y) (+ x y))
  #+END_SRC

- example 4

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)
  (let ((x 1)) (lambda (y) (+ x y)))
  ;; (closure ((x . 1) t) (y) (+ x y))
  #+END_SRC

- example 5

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)
  (let ((n 1)) (defun n+ (y) (+ n y)))
  (n+ 1) ; 2
  (let ((n -10)) (n+ 1)) ; 2
  #+END_SRC

- example 6

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding nil)
  (let ((n 1)) (defun n+ (y) (+ n y)))
  (should-error (n+ 1) :type 'void-variable) ; (void-variable n)
  (let ((n -10)) (n+ 1)) ; -9
  #+END_SRC

- example 7

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding nil)
  ;; Note that `lexical-let' is defined in `lisp/obsolete/cl.el'
  (lexical-let ((n 1)) (defun n+ (y) (+ n y)))
  (n+ 1) ; 2
  (let ((n -10)) (n+ 1)) ; 2
  #+END_SRC

- example 8

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)
  (setq xx 10)
  (let ((xx 1)) (defun xx+ (y) (+ xx y)))
  (xx+ 1) ; 2
  (let ((x -10)) (xx+ 1)) ; 2
  #+END_SRC

- example 9

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)
  (defvar xxx 10)
  (let ((xxx 1)) (defun xxx+ (y) (+ xxx y)))
  (xxx+ 1) ; 11
  (let ((xxx -10)) (xxx+ 1)) ; -9
  #+END_SRC

- example 10

  #+BEGIN_SRC emacs-lisp
  (setq lexical-binding t)
  (let ((xxxx 1)) (defun xxxx+ (y) (+ y xxxx)))
  (defvar xxxx 10)
  (xxxx+ 1) ; 11
  (let ((xxxx -10)) (xxxx+ 1)) ; -9
  #+END_SRC

** advanced example using lambda, let, dolist, defun

Evaluating the following forms with lexical binding:

#+BEGIN_SRC emacs-lisp
(setq lexical-binding t)

(defun call-f (f x)
  `(:x-in-call-f ,x
    :result-of-f ,(funcall f x)
    :type-of-f ,(car f)
    :env-of-f  ,(and (eq (car f) 'closure) (cadr f))))

(dolist (x '(1 2 3))
  (let ((f (lambda (y) `(:x-in-f ,x :y ,y))))
    (message "%S" (append `(:x-in-dolist ,x) (call-f f -1)))))
#+END_SRC

prints out the following into the message buffer:

#+BEGIN_SRC emacs-lisp
(:x-in-dolist 1
 :x-in-call-f -1
 :result-of-f (:x-in-f 1 :y -1)
 :type-of-f closure
 :env-of-f ((--dolist-tail-- 1 2 3) t))
(:x-in-dolist 2
 :x-in-call-f -1
 :result-of-f (:x-in-f 2 :y -1)
 :type-of-f closure
 :env-of-f ((--dolist-tail-- 2 3) t))
(:x-in-dolist 3
 :x-in-call-f -1
 :result-of-f (:x-in-f 3 :y -1)
 :type-of-f closure
 :env-of-f ((--dolist-tail-- 3) t))
#+END_SRC

Evaluating the following forms with dynamic binding:

#+BEGIN_SRC emacs-lisp
(setq lexical-binding nil)

(defun call-f (f x)
  `(:x-in-call-f ,x
    :result-of-f ,(funcall f x)
    :type-of-f ,(car f)
    :env-of-f  ,(and (eq (car f) 'closure) (cadr f))))

(dolist (x '(1 2 3))
  (let ((f (lambda (y) `(:x-in-f ,x :y ,y))))
    (message "%S" (append `(:x-in-dolist ,x) (call-f f -1)))))
#+END_SRC

prints out the following into the message buffer:

#+BEGIN_SRC emacs-lisp
(:x-in-dolist 1
 :x-in-call-f -1
 :result-of-f (:x-in-f -1 :y -1)
 :type-of-f lambda
 :env-of-f nil)
(:x-in-dolist 2
 :x-in-call-f -1
 :result-of-f (:x-in-f -1 :y -1)
 :type-of-f lambda
 :env-of-f nil)
(:x-in-dolist 3
 :x-in-call-f -1
 :result-of-f (:x-in-f -1 :y -1)
 :type-of-f lambda
 :env-of-f nil)
#+END_SRC
